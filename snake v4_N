// snake v4 changes from v3: rewritten with less global variables and more return functions
INCOMPLETE VERSION - WORK IN PROGRESS

#include <iostream>
#include <random> //for random food generator
#include <thread> //for sleep
using namespace std;

// BOARDSIZE
const int boardsize = 11;

// MATRICIES
int food_map[boardsize][boardsize]; //food matrix
int player_map[boardsize][boardsize]; //player matrix
int direction_map[boardsize][boardsize]; //direction matrix for pattern movements

// STATISTICS
long long moves_done;
long long moves_considered;
long long recalculations;
int score;
int highscore = 121;

// COORDINATES
//player coords
int i_player;
int j_player;
//player coords suggestions
int i_player_sug;
int j_player_sug;
//food coords
int i_food;
int j_food;
//what move should be tried next
int nextmove1; //state 1
int nextmove2; //state 2
int nextmove3; //state 3

// BOOLEANS
bool alive;
bool scored;
bool move_ok;
bool free_space;
//bool forever = true;
bool corner_changed; //path adjusted to get food in corner


// FUNCTIONS

void sleep1() {
    this_thread::sleep_for(std::chrono::milliseconds(150));
}



void update_player() {
    for (int i = 0; i < boardsize; i++) {
        for (int j = 0; j < boardsize; j++) {
            if (player_map[i][j] != 0) //check if a player is here
                player_map[i][j] --; //reduce the player value by 1
        }
    }
}

bool check_free_space(int random_number_1, int random_number_2) { //check if food can be spawned here
    if (player_map[random_number_1][random_number_2] == 0) {
        food_map[random_number_1][random_number_2] = -1; //spawn new food
        return free_space = true;
        } else {
            return free_space = false;
        }
}

int spawn_new_food() {
    free_space = false;
    int random_number_1 = 0;
    int random_number_2 = 0;
    while (!free_space) {
        random_device rd;
        mt19937 gen(rd());
        uniform_int_distribution<> distribution(0, boardsize-1);
        random_number_1 = distribution(gen);
        random_number_2 = distribution(gen);
        check_free_space(random_number_1, random_number_2);
    }
    return i_food = random_number_1;
    return j_food = random_number_2;
}

void draw_board() {
        //draw playing field with cout
    for (int i = 0; i < boardsize; i++) {
        for (int j = 0; j < boardsize; j++) {
            if (player_map[i][j] != 0) {
                cout << "0 ";
            } else {
                if (i == i_food && j == j_food) {
                    cout << "X ";
                } else {
                    cout << "- ";
                }
            }
        }
        cout << "\n";
    }
}

bool check_scored() {
        //check if player and food coordinates match
    if (i_player == i_food && j_player == j_food) {
        score ++;
        return scored = true;
    } else {
        return scored = false;
    }
}

bool check_alive() {
        //check if crashed in board walls
    if (i_player > boardsize-1 || j_player > boardsize-1 || i_player < 0 || j_player < 0) {
        return alive = false;
        //check if crashed in player(itself)
    } else if (player_map[i_player][j_player] != 0) {
        return alive = false;
    } else {
        return alive = true;
    }
}

bool checkmove() {
    moves_considered ++; //for statistic purposess only
    recalculations ++; //for statistic purposes only
        //check if crash in player
    if (player_map[i_player_sug][j_player_sug] != 0) {
        return move_ok = false;
        //check for borders
    } else if (i_player_sug < 0) {
        return move_ok = false;
    } else if (j_player_sug < 0) {
        return move_ok = false;
    } else if (i_player_sug > boardsize-1) {
        return move_ok = false;
    } else if (j_player_sug > boardsize-1) {
        return move_ok = false;
    } else {
        recalculations --;
        return move_ok = true;
    }
}

// GET MOVES

int getmove_s1_1() {
    if (i_player < i_food) {
        i_player_sug ++;
    } else if (i_player > i_food) {
        i_player_sug --;
    } else if (j_player < j_food) {
        j_player_sug ++;
    } else if (j_player > j_food) {
        j_player_sug --;
    }
    return i_player_sug;
    return j_player_sug;
}

void getmove_s1() {
    i_player_sug = i_player;
    j_player_sug = j_player;
    
    getmove_s1_1();
    checkmove();
    if (move_ok) {
        i_player = i_player_sug;
        j_player = j_player_sug;
    } else {
        // get a move somehow else
    }
}
